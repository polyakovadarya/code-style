Структура карточки
===

Авторы: [Георгий Грошев](https://github.com/eclegend), [Илья Назаров](https://github.com/ilich-x)

# Содержание
  * [Общая структура](#Общая-структура)
  * [_card.json](#_card.json)
  * [.json](#.json)
  * [.graph](#.graph)
  * [.js](#.js)
  * [.scss](#.scss)
  * [Дополнительная информация]

# Общая структура
## Карточка
Карточка - это индивидуальная самостоятельная единица контента. Карточка может считаться отдельным небольшим модулем, в котором есть входные данные (значения генерации) и свои под-модули (чанки). В карточке (интерактивном уроке) отрабатывается одна задача на одну тему.

Карточка в cms имеет свой уникальный идентификатор, например карточка 1140.

## Чанк
Чанк (от англ. chunk) - отдельная часть карточки. Карточка может состоять из 1 чанка, а может состоять из 4 (и более) чанков. В одном чанке может реализовываться новый способ решения задачи, отсутствуют подсказки, некоторые инпуты и т.д., отрабатываться новые генерации и т.п.

Чанки могут быть почти идентичны, а могут и кардинально отличаться.

Для каждого чанка создается **отдельный** скрипт и файл стилей.

Если чанки идентичны и отличаются только набором генераций, то допустимо оставить один скрипт.



Карточка состоит из 5 основных файлов:

1. `<номер карточки>_card.json`
2. `<номер скрипта>.json`
3. `<номер скрипта>.js.`
4. `<номер скрипта>.graph`
5. `<номер скрипта>.css.scss`

Обычно, к моменту разработки они уже сгенерированы и находятся в папке проекта по определенным путям.





Структура:

```d
content-{имя_проекта}/
├── cards/{класс}/{название_урока}/<номер_карточки>_card.json // json файлы карточек
└── src/{класс}/{номер_карточки}/{номер_скрипта} // основная папка разработчика контента
          ├── assets/ // изображения, графовые мискины, хелперы для карточек (при необходимости)
          ├── <номер_скрипта>.json // json скрипта
          ├── <номер_скрипта>.js // скрипт
          └── <номер_скрипта>.css.scss // файл стилей скрипта
```

# _card.json
`<номер карточки>_card.json` - файл содержит имя карточки, чанки, генерации, ссылки на скрипты по чанкам и др.

```json
// 11449_card.json
{
  "name_ru": "temp",
  "player": "/players/player-1",
  "supports": {
    "sound": "v2",
    "beads": "v4", // версия бусин
    "interbeads_congrat": "v1"
  },
  "progress": "beads", // прогресс измеряется в бусинах
  "chunks": [
    {
      "script": 17655, // номер скрипта
      "amount": 1, // количество бусин необходмое для прохождения чанка (при правильном ответе бусина перекатывается направо)
      "strategy": "stack", // стратегия по которой осуществляется переход к следующей генерации
      // "stack" - выглядит как массив объектов
      "generations": [
        {"expr": "4+5"},
        {"expr": "3+8"}
      ]
    },
    {
      "script": 17609,
      "amount": 1,
      "strategy": "stack_adaptive", 
      "stack_adaptive_beads": 1, // необязательный параметр
      "generations": {
        "stack": [
          "1",
          "2"
        ],
        "values": {
          "1":[
            {}
          ],
          "2":[
            {}
          ]
        }
      },
      "without_penalty": true // необязательный параметр делает бусину при ошибке неоткатной ( по договоренности с методистом ) по умолчанию false
    },
    ...
  ],
  "compiler_deps_version": "v4"
}
```

Все возможные стратегии: 
```json
{
"strategy": ["stack","stack_adaptive",  "stack_adaptive_with_variations","strategy_fix_mistakes","shuffle","increasing_stack"]
}
```

# .json

`<номер скрипта>.json` - в этом файле описываются параметры скрипта, подключение необходимых компонент, библиотек и прочего. А также текстовые контанты (текст хинтов, текстовые сообщения и др.)

```json
// файл 17662.json
{
  "name": "17662",
  "require": [ // сюда подключаеются необходимые компоненты
    "/components/system/kernel/30.0.0",
    "/components/system/scene/7.1.0",
    "/components/system/atoms-core/0.1.0",
    "/components/system/button/17.1.1",
    "/{пути_для_кастомных_библиотек_либо_ваших_файлов}",
    "17662.graph", // файл графа
    "17662.js", // наш файл js
    "17662.css" // файл стилей
  ],
  "const": { //Описание некоторых языковых констант (текст на кнопках, хинтах и т. п.)
    "title": {
      "ru": { // локаль, в данном случае русская
        "text": "ЗАГОЛОВОК",
        "audio": {
          "mp3": "/{путь_до_аудио}/121.mp3" // озвучка
        }
      },
      "en": {
        // Английские константы самостоятельно не нужно заполнять
      }
    },
    "done": {
      "ru": {
        "text": "Готово"
      }
    }
  },
  "supports": {
     "speaker": "v5", // подключение спикера в карточках с овзучкой
    "resources": "v2",
    "keypad": "v3", // версия виртуальной клавиатуры в разных проектах может отличаться
    "graph": {
      "state": "v2",
      "multitype": true
    }
  }
}
```
# graph
За логику скрипта отвечает программа на языке описания UchiGraph. Основная идея состоит в том, что любой сценарий можно реализовать с помощью небольших шагов с ветвлениями-условиями и форками (когда несколько шагов выполняется одновременно). Примерами шагов являются элементы сценария, такие как "птица перелетела в гнездо", "отрисовать автобус", "пользователь перетаскивает апельсинки", "показать хинт 'попробуй еще раз'" и так далее.
```
script_17676-->
init-->
render-->
start-->
continue-->
deinit-->
the_end();
```

TODO: fork, join, next(), task={}, delay


# .js
TODO: что то, хз что, все свзязано с графом

* [Шаг `init`. Инициализация](#Шаг-init-Инициализация)
* [Шаг `render`. Рендеринг](#Шаг-render-Рендеринг)
* [Шаг `start`. Начало](#Шаг-start-Начало)
* [Шаг `continue`. Продолжение](#Шаг-continue-Продолжение)
* [Шаг `deinit`. Окончание](#Шаг-deinit-Окончание)
* [OFFTOP](#offtop)


Вот так выглядит сгенерированный файл `17676.graph`. Номер скрипта может быть любым. В данном случае это `17676`. Самая первая строчка `script_17676-->` очень важна и не стоит ее удалять.

>Функции графа именуются `"шагами"` графа.

```
script_17676-->
init-->
render-->
start-->
continue-->
deinit-->
the_end();
```
---
## Шаг `init`. Инициализация

Все инстансы и `jQuery-элементы` создаются в шаге `init`.

Отделяем инстансы компонентов от `jQuery`-элементов. Записываем все инстансы компонентов в переменную `this.com`, а `jQuery`-элементы в `this.dom`. Так нам всегда будет видно в коде, к какой именно сущности мы обращаемся.

Можно разделять инициализацию на несколько шагов, если это вам нужно, но все их названия должны начинаться с `init...` и находиться до шага `render`.

Иногда для некоторых компонетов и методов (`this.tutor.speaker()`, `$$.Dragger()`) требуется наличие в DOM-е передаваемых им элементов в отрендеренном состоянии, для рассчета их позиций (что не очень хорошо), поэтому создание этих элементов может происходить в других шагах после шага `render` или в самом шаге `render`.

Переменная `this.salt` хранит в себе генерации из файла `_card.json`
```javascript
// init
$$.Script.prototype.init = function(cb) {
  // Генерации
  this.props = { ...this.salt };
  // Components
  this.com = {
    button: new $$.Button({
      content: this.tutor.t('done')
    })
  };
  // DOM
  this.dom = {
    button: this.com.button.view,
    buttonContainer: $.div('button-container'),
    scene: $.div('scene'),
    title: $.div('title')
      .html(this.tutor.t('title'))
  };
  cb();
};

```
---
## Шаг `render`. Рендеринг
Групповой рендер элементов в `DOM`. Так как `DOM` в браузере достаточно медленная структура, то лучше пореже обращаться к ней. Хоть для нас и не очень важна пока что производительность, но лучше привыкать к этому сразу.

Почти весь рендер (большая часть) должен происходить в шаге `render`. Можно разделять рендер на несколько шагов, если это вам нужно, но все их названия должны начинаться с `render...`. Например, если нужна инициализация каких то компонентов, требующих уже отрендеренных компонентов.

Плюс, если мы будем рендерить все первые элементы все разом в шаге `render`, то унас будет перед глазами наглядная структура того, что у нас есть в `DOM`-е на данный момент.

```javascript
// render
$$.Script.prototype.render = function(cb) {
  // Scene
  this.place.append(
    this.dom.scene.append(
      this.dom.title,
      this.dom.buttonContainer.append(
        this.dom.button
      )
    )
  );
  cb();
};
```
---
## Шаг `start`. Начало
Здесь мы только отображаем нашу кнопку play_button и слушаем нажатие.

```javascript
// start
$$.Script.prototype.start = function(cb) {
  this.tutor.play_button(cb);
};
```
---
## Шаг `continue`. Продолжение
Этот шаг вспомогательный. Сюда мы возвращаемся каждый раз, если у нас есть какие-то циклические повторения (экраны, fork-и, проверки). Здесь же мы сбрасываем состояние нашего скрипта, если нужно (`this.state.action`, `this.state.error`).

```javascript
// continue
$$.Script.prototype.continue = function(cb) {
  this.state.action = null;
  this.state.error = false;
  cb();
};
```

## Шаг `deinit`. Окончание
Здесь мы очищаем нашу сцену, и снимаем обработчики событий с других элементов, если нужно.

```javascript
// deinit
$$.Script.prototype.deinit = function(cb) {
  $$.scene__clear(this.dom.scene);
  cb();
};
```

# .scss
TODO: ASSET_PATH, &{}